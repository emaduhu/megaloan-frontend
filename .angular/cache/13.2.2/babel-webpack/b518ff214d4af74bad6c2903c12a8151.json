{"ast":null,"code":"import _classCallCheck from \"/home/evaristus/PycharmProjects/tpdc/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/evaristus/PycharmProjects/tpdc/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { HttpRequest, HttpResponse, HttpHandler, HttpEvent, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { of, throwError } from 'rxjs';\nimport { delay, mergeMap, materialize, dematerialize } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nvar users = [{\n  id: 1,\n  username: 'test',\n  email: '',\n  roles: [],\n  tokenType: '',\n  accessToken: ''\n}];\nexport var FakeBackendInterceptor = /*#__PURE__*/(function () {\n  var FakeBackendInterceptor = /*#__PURE__*/function () {\n    function FakeBackendInterceptor() {\n      _classCallCheck(this, FakeBackendInterceptor);\n    }\n\n    _createClass(FakeBackendInterceptor, [{\n      key: \"intercept\",\n      value: function intercept(request, next) {\n        var url = request.url,\n            method = request.method,\n            headers = request.headers,\n            body = request.body; // wrap in delayed observable to simulate server api call\n\n        return of(null).pipe(mergeMap(handleRoute)).pipe(materialize()) // call materialize and dematerialize to ensure delay even if an error is thrown (https://github.com/Reactive-Extensions/RxJS/issues/648)\n        .pipe(delay(500)).pipe(dematerialize());\n\n        function handleRoute() {\n          switch (true) {\n            case url.endsWith('/users/authenticate') && method === 'POST':\n              return authenticate();\n\n            case url.endsWith('/users') && method === 'GET':\n              return getUsers();\n\n            default:\n              // pass through any requests not handled above\n              return next.handle(request);\n          }\n        } // route functions\n\n\n        function authenticate() {\n          var username = body.username,\n              password = body.password;\n          var user = users.find(function (x) {\n            return x.username === username;\n          } // && x.password === password\n          );\n          if (!user) return error('Username or password is incorrect');\n          return ok({\n            id: user.id,\n            username: user.username,\n            firstName: '',\n            lastName: '',\n            accessToken: 'fake-jwt-token'\n          });\n        }\n\n        function getUsers() {\n          if (!isLoggedIn()) return unauthorized();\n          return ok(users);\n        } // helper functions\n\n\n        function ok(body) {\n          return of(new HttpResponse({\n            status: 200,\n            body: body\n          }));\n        }\n\n        function error(message) {\n          return throwError({\n            error: {\n              message: message\n            }\n          });\n        }\n\n        function unauthorized() {\n          return throwError({\n            status: 401,\n            error: {\n              message: 'Unauthorised'\n            }\n          });\n        }\n\n        function isLoggedIn() {\n          return headers.get('Authorization') === 'Bearer fake-jwt-token';\n        }\n      }\n    }]);\n\n    return FakeBackendInterceptor;\n  }();\n\n  FakeBackendInterceptor.ɵfac = function FakeBackendInterceptor_Factory(t) {\n    return new (t || FakeBackendInterceptor)();\n  };\n\n  FakeBackendInterceptor.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: FakeBackendInterceptor,\n    factory: FakeBackendInterceptor.ɵfac\n  });\n  return FakeBackendInterceptor;\n})();\nexport var fakeBackendProvider = {\n  // use fake backend in place of Http service for backend-less development\n  provide: HTTP_INTERCEPTORS,\n  useClass: FakeBackendInterceptor,\n  multi: true\n};","map":null,"metadata":{},"sourceType":"module"}